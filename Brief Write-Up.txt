	When I started learning about the Bevy game engine, I was in the market to look for potential replacements for the Unity game engine since there was a change in it’s user policy. Going into the project, I expected a user interface and usable game engine similar to unity. Though, I quickly realized that not all engines work the same.
	The second-to-largest struggle was learning to work with an entity-component system (ECS) rather than a system with an obvious UI. The game engine felt like it worked drastically different from what I was used to, and usage took time to get the handle off. It was a bummer, since I was used to being able to work with colliders and rigidbody in Unity, but I couldn’t implement the same systems right off the bat like I had hoped. Though, after some time, I was able to figure out how to work with ECS, and make a decent first-game project.
	The first largest struggle, however, was how unfinished the Bevy engine seemed to be–at least for my windows computer, and/or tutorials appeared to be out of date. When trying to implement rigidbody (essentially physics and gravity) to my characters, the system would refuse to compile; running with an unknown error despite being compiled and built with no issue at all. I almost ended up building a script for rigidbody myself until changing the project. Though, the project did push me to look into what building my own game engine and systems would take, which was a very attractive thought.
	Overall, bevy feels incomplete and frankly inferior compared to some other existing game engines, but it did push me to think about game development in other ways, and to think about what would go into making my own game engine in the future.
